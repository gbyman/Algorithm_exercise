package algorithm_sort;
//쉘 소트
public class ShellSort {
	
//	쉘 소트를 이용하여 배열을 정렬한다
//	
//	@param a 정렬할 배열
	public static void sort(int[] a) {
		
		int n = a.length; //배열의 요소 수
		int h;
		
		//h=1에서 시작하여 '3배 한 후 1을 더하는' 조작을 반복하여 n/9를 넘지않는 최대 값을 구한다
		//이 때 'n을 넘지않는'이 아니라 'n/9를 넘지 않는'으로 한 것은 매우 멀리 떨어진 요소를 h-소트 해봐야 별다른 이득이 없고
		//오히려 시간만 더 걸리기 때문이다.
		for (h = 1; h < n/9; h = h * 3 + 1);
		
		for(; h > 0; h/= 3) { //변수 h를 16행의 for문에서 구해진 최대 값으로 초기화한 후 1이 될 때까지 순서대로 변화시킨다
								//이 때, h는 정수이기 때문에 3으로 나눔으로써 수열이 반대방향으로 생성되게 한다
			for (int i = h; i < n; i++) {
				//삽입 소트와 쉘 소트르 ㄹ비교해 보면 삽입 소트에서는 외부 루프에서 i의 초기값이 1이지만
				//쉘 소트에서는 i의 초기값이 h이다. 또, 삽입 소트에서 a[j-1]로 요소를 참조하지만
				//쉘 소트에서는 a[j-h]로 참조한다. 거기다 삽입 소트에서는 내부 루프를 실행할 때마다 루프 변수 j를 1씩 감소시키지만
				//쉘 소트에서는 h씩 감소시킨다. 즉, 쉘 소트의 안쪽 이중 루프는 삽입 소트에서 1로 있는 부분을 모두 h로 바꾼 것과 같다.
				//이것은 삽입 소트에서는 인접한 요소를 비교, 교환의 대상으로 하는데 비해, 쉘 소트에서는 h만큼 떨어진 요소를 대상으로 하기 때문이다.
				//그리고 이 삽입 소트의 처리를 h값을 변경하며 반복하는 루프(18행의 for 루프)로 둘러싼 것이 쉘 소트가 된다
				//겨우 이 정도의 변경만으로 복잡도 O(n제곱)이 약 O(n의 1.25승)으로 되기 때문에 매우 이득이라고 할 수 있다.
				//요소 수가 그다지 많지 않은 경우에는 항상 쉘 소트를 사용하는 것이 좋다. 
				//단순 정렬 알고리즘은 실제 프로그램을 작성할 때에는 되도록 사용하지 않는 것이 좋다.
				int j = i;
				while(j >= h && a[j - h] > a[j]) {
					int temp = a[j];
					a[j] = a[j-h];
					a[j - h] = temp;
					j -= h;
				}
			}
		}
	}
	
}
